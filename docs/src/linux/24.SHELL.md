# Shell 学习教程
## 前言
Shell 是操作系统的命令行解释器，用于接收用户输入的命令并执行，是 Linux/Unix 系统的核心工具之一。本教程将从基础语法到高级应用，循序渐进讲解 Shell 编程，适合零基础入门者，也可作为日常查阅手册。

## 一、Shell 基础入门
### 1.1 什么是 Shell？
- **定义**：Shell 是用户与操作系统内核之间的交互接口，将用户命令翻译成内核能理解的指令，同时将内核执行结果反馈给用户。
- **常见 Shell**：
  - `bash`：Linux 系统默认 Shell（本教程基于 bash）
  - `sh`：Unix 原始 Shell
  - `zsh`：增强型 Shell，兼容 bash，支持更多插件
- **验证当前 Shell**：
  ```bash
  echo $SHELL  # 输出当前使用的 Shell，如 /bin/bash
  cat /etc/shells  # 查看系统支持的所有 Shell
  ```

### 1.2 第一个 Shell 脚本
#### 1.2.1 脚本结构
Shell 脚本文件以 `.sh` 为后缀，首行需指定解释器（谢邦约定）：
```bash
#!/bin/bash  # 指定使用 bash 解释器
# 这是注释（# 开头的行为注释，不会执行）
echo "Hello, Shell!"  # 输出字符串
```

#### 1.2.2 执行脚本的 3 种方式
1. **赋予执行权限（推荐）**：
   ```bash
   chmod +x hello.sh  # 赋予脚本执行权限
   ./hello.sh         # 执行脚本（必须加 ./，表示当前目录）
   ```
2. **通过 bash 解释器执行**（无需执行权限）：
   ```bash
   bash hello.sh
   ```
3. **source 执行**（脚本在当前 Shell 环境运行，变量会保留）：
   ```bash
   source hello.sh  # 或 . hello.sh（注意空格）
   ```

### 1.3 常用基础命令
#### 1.3.1 文件/目录操作
| 命令 | 功能 | 示例 |
|------|------|------|
| `ls` | 列出目录内容 | `ls -l`（详细列表）、`ls -a`（显示隐藏文件） |
| `cd` | 切换目录 | `cd /home`（绝对路径）、`cd ../`（上级目录） |
| `pwd` | 显示当前目录路径 | `pwd` |
| `mkdir` | 创建目录 | `mkdir test`（单个目录）、`mkdir -p a/b/c`（递归创建） |
| `touch` | 创建空文件 | `touch file.txt` |
| `cp` | 复制文件/目录 | `cp file.txt dir/`、`cp -r dir1 dir2`（复制目录） |
| `mv` | 移动/重命名 | `mv file.txt new.txt`（重命名）、`mv file.txt dir/` |
| `rm` | 删除文件/目录 | `rm file.txt`、`rm -rf dir`（强制删除目录） |
| `cat` | 查看文件内容 | `cat file.txt` |
| `more/less` | 分页查看大文件 | `less log.txt`（按 q 退出） |
| `head/tail` | 查看文件首尾 | `head -10 file.txt`（前 10 行）、`tail -f log.txt`（实时监控） |

#### 1.3.2 系统/进程操作
- `ps`：查看进程
  ```bash
  ps aux  # 查看所有进程
  ps aux | grep java  # 过滤包含 java 的进程
  ```
- `kill`：终止进程
  ```bash
  kill -9 1234  # 强制终止 PID 为 1234 的进程
  ```
- `top`：实时监控系统资源（按 q 退出）
- `df`：查看磁盘空间
  ```bash
  df -h  # 人类可读格式显示
  ```
- `free`：查看内存使用
  ```bash
  free -h
  ```

#### 1.3.3 其他常用命令
- `echo`：输出内容
  ```bash
  echo "Hello"  # 输出字符串
  echo $PATH    # 输出环境变量
  ```
- `date`：显示当前时间
  ```bash
  date "+%Y-%m-%d %H:%M:%S"  # 自定义格式
  ```
- `grep`：文本搜索（强大的过滤工具）
  ```bash
  grep "error" log.txt  # 搜索 log.txt 中的 error 关键字
  grep -i "error" log.txt  # 忽略大小写
  grep -n "error" log.txt  # 显示行号
  grep -r "error" /var/log/  # 递归搜索目录
  ```
- `pipe（|）`：管道符，将前一个命令的输出作为后一个命令的输入
  ```bash
  ls -l | grep ".txt"  # 列出当前目录下所有 .txt 文件
  ```

## 二、Shell 变量与数据类型
### 2.1 变量定义与使用
#### 2.1.1 基本规则
- 变量名由字母、数字、下划线组成，不能以数字开头
- 变量赋值时，`=` 两边不能有空格（重要！）
- 使用变量时，前面加 `$`，或 `${变量名}`（推荐，避免歧义）

#### 2.1.2 示例
```bash
#!/bin/bash
# 定义变量
name="Alice"
age=25
height=1.65

# 使用变量
echo "姓名：$name"
echo "年龄：${age}岁"  # 加 {} 更规范，尤其拼接字符串时
echo "身高：${height}m"

# 变量重新赋值
age=26
echo "更新后年龄：$age"
```

### 2.2 变量类型
Shell 是弱类型语言，无需声明类型，自动根据值推断：
1. **字符串型**：
   - 单引号 `' '`：原样输出，不解析变量和转义字符
   - 双引号 `" "`：解析变量和转义字符（如 `\n` 换行）
   - 无引号：与双引号类似，但不解析空格和特殊字符
   ```bash
   str1='Hello $name'  # 输出 Hello $name
   str2="Hello $name"  # 输出 Hello Alice
   str3=Hello$name     # 输出 HelloAlice（无空格时拼接）
   ```
2. **数值型**：整数和浮点数（浮点数运算需借助 `bc` 工具）
3. **数组**：存储多个值（索引从 0 开始）
   ```bash
   # 定义数组
   fruits=("apple" "banana" "orange")
   # 访问单个元素
   echo ${fruits[0]}  # 输出 apple
   # 访问所有元素
   echo ${fruits[@]}  # 或 ${fruits[*]}，输出 apple banana orange
   # 数组长度
   echo ${#fruits[@]}  # 输出 3
   ```

### 2.3 环境变量与预定义变量
#### 2.3.1 环境变量
系统预先定义的变量，用于控制 Shell 行为：
- `PATH`：命令搜索路径（新增路径：`export PATH=$PATH:/新路径`）
- `HOME`：当前用户主目录
- `USER`：当前用户名
- `PWD`：当前工作目录
- `$?`：上一个命令的执行结果（0 表示成功，非 0 表示失败）

示例：
```bash
echo $HOME  # 输出 /home/username
echo $PATH  # 输出命令搜索路径
ls non_exist_file
echo $?  # 输出非 0（表示上一条命令失败）
```

#### 2.3.2 预定义变量
Shell 内置的特殊变量，无需定义即可使用：
| 变量 | 功能 |
|------|------|
| `$0` | 脚本文件名 |
| `$1-$9` | 脚本的第 1-9 个参数 |
| `$*` | 所有参数（作为一个整体） |
| `$@` | 所有参数（每个参数独立） |
| `$#` | 参数个数 |
| `$$` | 当前脚本的 PID |
| `$?` | 上一条命令的退出状态 |

示例（`args.sh`）：
```bash
#!/bin/bash
echo "脚本名：$0"
echo "第 1 个参数：$1"
echo "第 2 个参数：$2"
echo "所有参数（\$*）：$*"
echo "所有参数（\$@）：$@"
echo "参数个数：$#"
echo "当前脚本 PID：$$"
```

执行：
```bash
bash args.sh a b c
# 输出：
# 脚本名：args.sh
# 第 1 个参数：a
# 第 2 个参数：b
# 所有参数（$*）：a b c
# 所有参数（$@）：a b c
# 参数个数：3
# 当前脚本 PID：12345
```

### 2.4 变量运算
#### 2.4.1 整数运算
常用方式：
1. `$((表达式))`（推荐）
2. `$[表达式]`
3. `expr 表达式`（注意运算符两边需空格）

示例：
```bash
a=10
b=5

# 加法
echo $((a + b))  # 输出 15
# 减法
echo $((a - b))  # 输出 5
# 乘法（不能用 *，需转义或用 $(( ))）
echo $((a * b))  # 输出 50
# 除法（整数除法，舍去小数）
echo $((a / b))  # 输出 2
# 取余
echo $((a % b))  # 输出 0
# 自增
echo $((a++))  # 先输出 10，再 a=11
echo $((++a))  # 先 a=12，再输出 12
```

#### 2.4.2 浮点数运算
Shell 不直接支持浮点数运算，需借助 `bc` 工具（精度可通过 `scale` 控制）：
```bash
# 加法
echo "1.2 + 3.4" | bc  # 输出 4.6
# 乘法
echo "2.5 * 4.2" | bc  # 输出 10.5
# 控制精度（保留 2 位小数）
echo "scale=2; 10 / 3" | bc  # 输出 3.33
```

## 三、Shell 流程控制
### 3.1 条件判断（if-else）
#### 3.1.1 基本语法
```bash
if [ 条件表达式 ]; then
  # 条件成立时执行
elif [ 条件表达式 ]; then
  # 上一个条件不成立时执行
else
  # 所有条件都不成立时执行
fi
```
- 注意：`[ ]` 两边必须有空格！
- 多条件判断可用 `&&`（且）、`||`（或）

#### 3.1.2 条件表达式类型
1. **文件判断**：
   | 表达式 | 功能 |
   |--------|------|
   | `-f file` | 文件是否存在且为普通文件 |
   | `-d dir` | 目录是否存在 |
   | `-e path` | 路径（文件/目录）是否存在 |
   | `-r file` | 文件是否可读 |
   | `-w file` | 文件是否可写 |
   | `-x file` | 文件是否可执行 |

2. **数值比较**：
   | 表达式 | 功能 | 等价写法（用于 (( )) 中） |
   |--------|------|--------------------------|
   | `-eq` | 等于 | `==` |
   | `-ne` | 不等于 | `!=` |
   | `-gt` | 大于 | `>` |
   | `-lt` | 小于 | `<` |
   | `-ge` | 大于等于 | `>=` |
   | `-le` | 小于等于 | `<=` |

3. **字符串比较**：
   | 表达式 | 功能 |
   |--------|------|
   | `str1 == str2` | 字符串相等 |
   | `str1 != str2` | 字符串不相等 |
   | `-z str` | 字符串长度为 0 |
   | `-n str` | 字符串长度不为 0 |

#### 3.1.3 示例
```bash
#!/bin/bash
file="test.txt"
num1=10
num2=20
str1="hello"
str2="world"

# 文件判断
if [ -f $file ]; then
  echo "$file 是普通文件"
elif [ -d $file ]; then
  echo "$file 是目录"
else
  echo "$file 不存在"
fi

# 数值比较
if ((num1 > num2)); then
  echo "$num1 > $num2"
else
  echo "$num1 <= $num2"
fi

# 字符串比较
if [ $str1 == $str2 ]; then
  echo "字符串相等"
else
  echo "字符串不相等"
fi

# 多条件判断（且）
if [ -n $str1 ] && [ $num1 -lt 15 ]; then
  echo "str1 非空且 num1 < 15"
fi
```

### 3.2 循环结构
#### 3.2.1 for 循环
##### 1. 遍历列表
```bash
#!/bin/bash
# 遍历字符串列表
for fruit in apple banana orange; do
  echo "水果：$fruit"
done

# 遍历数组
fruits=("apple" "banana" "orange")
for fruit in ${fruits[@]}; do
  echo "水果：$fruit"
done

# 遍历数字范围（1-5）
for i in {1..5}; do
  echo "数字：$i"
done

# 遍历数字范围（步长 2，1-10 奇数）
for i in {1..10..2}; do
  echo "奇数：$i"
done
```

##### 2. C 语言风格 for 循环
```bash
#!/bin/bash
for ((i=0; i<5; i++)); do
  echo "i = $i"
done

# 求和 1-100
sum=0
for ((i=1; i<=100; i++)); do
  sum=$((sum + i))
done
echo "1-100 求和：$sum"
```

#### 3.2.2 while 循环
```bash
#!/bin/bash
# 基本 while 循环（计数 1-5）
i=1
while [ $i -le 5 ]; do
  echo "i = $i"
  i=$((i + 1))
done

# 无限循环（需手动终止）
while true; do
  echo "无限循环中..."
  sleep 1  # 暂停 1 秒
done
```

#### 3.2.3 until 循环（条件不成立时执行）
```bash
#!/bin/bash
i=1
until [ $i -gt 5 ]; do  # 当 i>5 时停止
  echo "i = $i"
  i=$((i + 1))
done
```

#### 3.2.4 循环控制语句
- `break`：跳出当前循环
- `continue`：跳过当前循环的剩余部分，进入下一次循环

示例：
```bash
#!/bin/bash
# break 示例（循环到 3 跳出）
for i in {1..5}; do
  if [ $i -eq 3 ]; then
    break
  fi
  echo "i = $i"
done

# continue 示例（跳过 3）
for i in {1..5}; do
  if [ $i -eq 3 ]; then
    continue
  fi
  echo "i = $i"
done
```

### 3.3 case 语句（多分支判断）
#### 3.3.1 基本语法
```bash
case $变量 in
  模式1)
    执行命令1
    ;;  # 结束当前分支（类似 break）
  模式2)
    执行命令2
    ;;
  *)  # 所有模式不匹配时执行（默认分支）
    执行默认命令
    ;;
esac
```

#### 3.3.2 示例
```bash
#!/bin/bash
read -p "请输入 1-3 之间的数字：" num

case $num in
  1)
    echo "你输入了 1"
    ;;
  2)
    echo "你输入了 2"
    ;;
  3)
    echo "你输入了 3"
    ;;
  *)
    echo "输入错误！请输入 1-3 之间的数字"
    ;;
esac
```

## 四、Shell 函数
### 4.1 函数定义与调用
#### 4.1.1 基本语法
```bash
# 方式 1（推荐）
函数名() {
  函数体
  [return 返回值]  # 返回值为整数（0-255），默认返回最后一条命令的执行状态
}

# 方式 2
function 函数名 {
  函数体
}
```

#### 4.1.2 示例
```bash
#!/bin/bash
# 定义无参数函数
hello() {
  echo "Hello, Shell 函数！"
}

# 调用函数
hello

# 定义带参数函数（函数内通过 $1-$n 接收参数）
sum() {
  a=$1
  b=$2
  echo $((a + b))
}

# 调用带参数函数
result=$(sum 10 20)  # 捕获函数输出
echo "10 + 20 = $result"

# 定义带返回值函数
check_file() {
  file=$1
  if [ -f $file ]; then
    return 0  # 存在，返回 0（成功）
  else
    return 1  # 不存在，返回 1（失败）
  fi
}

# 调用带返回值函数
check_file "test.txt"
if [ $? -eq 0 ]; then
  echo "文件存在"
else
  echo "文件不存在"
fi
```

### 4.2 函数参数与返回值
- **参数传递**：函数调用时，参数直接跟在函数名后，函数内通过 `$1-$n`、`$*`、`$@` 接收（与脚本参数一致）
- **返回值**：
  1. `return` 语句：只能返回整数（0-255），用于表示执行状态（0 成功，非 0 失败）
  2. 输出捕获：通过 `result=$(函数名)` 捕获函数的 `echo` 输出（支持任意类型）

示例（捕获输出）：
```bash
#!/bin/bash
# 计算两数乘积（返回浮点数）
multiply() {
  a=$1
  b=$2
  echo "scale=2; $a * $b" | bc  # 输出浮点数结果
}

# 捕获函数输出
result=$(multiply 2.5 3.4)
echo "2.5 * 3.4 = $result"  # 输出 8.50
```

### 4.3 全局变量与局部变量
- **全局变量**：默认情况下，函数内定义的变量是全局的（整个脚本可访问）
- **局部变量**：用 `local` 关键字定义，仅在函数内部有效

示例：
```bash
#!/bin/bash
global_var="全局变量"

test_var() {
  local local_var="局部变量"  # 局部变量
  global_var="函数内修改后的全局变量"  # 修改全局变量
  echo "函数内：local_var = $local_var"
  echo "函数内：global_var = $global_var"
}

test_var
echo "函数外：local_var = $local_var"  # 输出空（局部变量不可访问）
echo "函数外：global_var = $global_var"  # 输出修改后的值
```

## 五、Shell 高级应用
### 5.1 文本处理工具
Shell 结合文本处理工具（grep、sed、awk）可实现强大的文本分析功能，以下是常用场景：

#### 5.1.1 sed（流编辑器，用于文本替换、删除、插入）
- 基本语法：`sed [选项] '命令' 文件名`
- 常用选项：
  - `-i`：直接修改文件（不加 `-i` 仅输出结果，不修改原文件）
  - `-n`：静默模式，只输出匹配的行
- 常用命令：
  - `s/旧字符串/新字符串/g`：全局替换（g 表示全局，不加则只替换每行第一个）
  - `d`：删除匹配的行
  - `p`：打印匹配的行

示例：
```bash
# 替换文件中所有 "hello" 为 "HELLO"（输出结果，不修改原文件）
sed 's/hello/HELLO/g' test.txt

# 直接修改文件（替换所有 "hello" 为 "HELLO"）
sed -i 's/hello/HELLO/g' test.txt

# 删除包含 "error" 的行（直接修改文件）
sed -i '/error/d' test.txt

# 打印包含 "success" 的行
sed -n '/success/p' test.txt
```

#### 5.1.2 awk（文本分析工具，按列处理文本）
- 基本语法：`awk '条件 {动作}' 文件名`
- 核心概念：
  - 按行处理文本，默认以空格/制表符为分隔符
  - `$0`：整行内容
  - `$1-$n`：第 1-n 列内容
  - `NR`：当前行号
  - `NF`：当前行的列数

示例：
```bash
# 查看 /etc/passwd 文件的第 1 列（用户名）和第 7 列（Shell）
awk -F ':' '{print $1 "\t" $7}' /etc/passwd  # -F 指定分隔符为 :

# 打印第 3 行内容
awk 'NR==3 {print $0}' test.txt

# 打印列数大于 3 的行
awk 'NF>3 {print $0}' test.txt

# 求和（计算第 2 列的总和）
awk '{sum += $2} END {print sum}' numbers.txt
```

### 5.2 正则表达式
正则表达式是文本匹配的规则，常用于 grep、sed、awk 中，以下是常用元字符：

| 元字符 | 功能 | 示例 |
|--------|------|------|
| `.` | 匹配任意单个字符（除换行） | `a.b` 匹配 aab、acb、adb 等 |
| `*` | 匹配前一个字符 0 次或多次 | `ab*` 匹配 a、ab、abb、abbb 等 |
| `+` | 匹配前一个字符 1 次或多次 | `ab+` 匹配 ab、abb、abbb 等 |
| `?` | 匹配前一个字符 0 次或 1 次 | `ab?` 匹配 a、ab |
| `^` | 匹配行首 | `^hello` 匹配以 hello 开头的行 |
| `$` | 匹配行尾 | `world$` 匹配以 world 结尾的行 |
| `[]` | 匹配括号内任意一个字符 | `[abc]` 匹配 a、b 或 c |
| `[^]` | 匹配括号内以外的任意字符 | `[^abc]` 匹配非 a、b、c 的字符 |
| `()` | 分组 | `(ab)+` 匹配 ab、abab、ababab 等 |
| `\|` | 或 | `a\|b` 匹配 a 或 b |

示例（grep 结合正则）：
```bash
# 匹配以 "error" 开头的行
grep '^error' log.txt

# 匹配以 ".txt" 结尾的行
grep '\.txt$' file.txt  # . 是元字符，需转义为 \.

# 匹配包含 3-5 个数字的字符串
grep '[0-9]\{3,5\}' test.txt
```

### 5.3 脚本调试与优化
#### 5.3.1 脚本调试
bash 提供调试选项，帮助定位脚本错误：
- `-n`：检查脚本语法错误（不执行）
  ```bash
  bash -n script.sh
  ```
- `-v`：执行前打印脚本内容，便于跟踪
  ```bash
  bash -v script.sh
  ```
- `-x`：执行时打印每条命令（最常用，显示命令执行过程）
  ```bash
  bash -x script.sh
  ```

#### 5.3.2 脚本优化技巧
1. 避免多余的子进程（如 `echo $(command)` 可简化为 `command`）
2. 循环中尽量减少文件 I/O 操作（如批量处理时先缓存数据）
3. 使用局部变量（`local`）提高函数执行效率
4. 避免使用 `eval`（存在安全风险，且效率低）
5. 对关键命令添加错误处理（通过 `$?` 或 `set -e`）

### 5.4 后台执行与定时任务
#### 5.4.1 后台执行脚本
- 脚本后加 `&`：后台执行，终端关闭后进程终止
  ```bash
  ./script.sh &
  ```
- `nohup`：后台执行，终端关闭后进程继续运行（输出重定向到 nohup.out）
  ```bash
  nohup ./script.sh &
  ```
- 查看后台进程：`jobs`
- 切换后台进程到前台：`fg %进程编号`（如 `fg %1`）

#### 5.4.2 定时任务（crontab）
crontab 用于定期执行脚本或命令，格式如下：
```
* * * * * 命令/脚本路径
# 分 时 日 月 周（0-6，0 表示周日）
```

常用操作：
- `crontab -e`：编辑定时任务
- `crontab -l`：查看定时任务
- `crontab -r`：删除所有定时任务

示例：
```bash
# 每天凌晨 2 点执行备份脚本
0 2 * * * /home/user/backup.sh

# 每小时的第 30 分钟执行脚本
30 * * * * /home/user/script.sh

# 每周日上午 10 点执行脚本
0 10 * * 0 /home/user/weekly.sh
```
### 5.5 高级应用示例

#### 5.5.1 批量文件重命名工具
实现按规则批量重命名文件（例如：统一添加前缀、替换字符、按序号命名）：
```bash
#!/bin/bash
# 批量重命名脚本：给指定目录下的 .txt 文件添加日期前缀
# 使用方法：./rename.sh [目录路径]

# 检查参数
if [ $# -ne 1 ]; then
  echo "使用方法：$0 [目录路径]"
  exit 1
fi

DIR=$1
DATE=$(date +%Y%m%d)

# 检查目录是否存在
if [ ! -d "$DIR" ]; then
  echo "错误：目录 $DIR 不存在！"
  exit 1
fi

# 遍历目录下的 .txt 文件
count=0
for file in "$DIR"/*.txt; do
  # 跳过非文件（如目录或无匹配文件）
  [ -f "$file" ] || continue
  
  # 提取文件名（不含路径）
  filename=$(basename "$file")
  # 新文件名：日期_原文件名
  new_filename="${DATE}_${filename}"
  # 重命名
  mv -v "$file" "$DIR/$new_filename"
  count=$((count + 1))
done

echo "重命名完成，共处理 $count 个文件"
```


#### 5.5.2 日志分析与告警脚本
分析应用日志中的错误信息，超过阈值时发送邮件告警：
```bash
#!/bin/bash
# 日志监控告警脚本：监控 error 出现次数，超过阈值则告警
# 使用方法：./log_alert.sh [日志文件] [阈值] [告警邮箱]

# 参数检查
if [ $# -ne 3 ]; then
  echo "使用方法：$0 [日志文件] [阈值] [告警邮箱]"
  exit 1
fi

LOG_FILE=$1
THRESHOLD=$2
ALERT_EMAIL=$3

# 检查日志文件
if [ ! -f "$LOG_FILE" ]; then
  echo "错误：日志文件 $LOG_FILE 不存在！"
  exit 1
fi

# 统计过去 1 小时的 error 次数
ERROR_COUNT=$(grep -c "ERROR" "$LOG_FILE" | grep "$(date -d '1 hour ago' +'%Y-%m-%d %H')")

# 对比阈值
if [ $ERROR_COUNT -gt $THRESHOLD ]; then
  # 提取最近 10 条错误日志
  ERROR_DETAILS=$(grep "ERROR" "$LOG_FILE" | grep "$(date -d '1 hour ago' +'%Y-%m-%d %H')" | tail -10)
  
  # 发送邮件告警（需安装 mailutils）
  echo "告警：日志 $LOG_FILE 在过去 1 小时内出现 $ERROR_COUNT 次 ERROR（阈值：$THRESHOLD）
  最近 10 条错误日志：
  $ERROR_DETAILS" | mail -s "【紧急】应用日志错误告警" "$ALERT_EMAIL"
  
  echo "已发送告警邮件至 $ALERT_EMAIL，错误次数：$ERROR_COUNT"
else
  echo "当前错误次数：$ERROR_COUNT，未超过阈值 $THRESHOLD"
fi
```


#### 5.5.3 服务器性能监控与数据持久化
定期收集 CPU、内存、磁盘使用率，写入文件并生成简单报告：
```bash
#!/bin/bash
# 系统性能监控脚本：定期记录系统状态并生成日报
# 配合 crontab 使用：*/30 * * * * /path/to/monitor.sh（每 30 分钟执行一次）

# 数据存储路径
DATA_FILE="/var/log/system_monitor.csv"
REPORT_FILE="/var/log/system_daily_report.txt"

# 初始化 CSV 文件（如果不存在）
if [ ! -f "$DATA_FILE" ]; then
  echo "时间,CPU使用率(%),内存使用率(%),磁盘使用率(/)" > "$DATA_FILE"
fi

# 获取当前时间
TIME=$(date "+%Y-%m-%d %H:%M:%S")

# 获取 CPU 使用率
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')

# 获取内存使用率
MEM_TOTAL=$(free -m | grep Mem | awk '{print $2}')
MEM_USED=$(free -m | grep Mem | awk '{print $3}')
MEM_USAGE=$(echo "scale=2; $MEM_USED / $MEM_TOTAL * 100" | bc)

# 获取磁盘使用率（/ 分区）
DISK_USAGE=$(df -h | grep "/$" | awk '{print $5}' | sed 's/%//')

# 写入数据
echo "$TIME,$CPU_USAGE,$MEM_USAGE,$DISK_USAGE" >> "$DATA_FILE"

# 每日凌晨生成日报（通过时间判断）
if [ "$(date +%H:%M)" = "00:00" ]; then
  # 计算昨日日期
  YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
  
  # 提取昨日数据
  YESTERDAY_DATA=$(grep "$YESTERDAY" "$DATA_FILE")
  
  # 计算 CPU 平均使用率
  CPU_AVG=$(echo "$YESTERDAY_DATA" | awk -F ',' '{sum += $2} END {print sum/NR}' | bc -l | xargs printf "%.2f")
  
  # 计算内存平均使用率
  MEM_AVG=$(echo "$YESTERDAY_DATA" | awk -F ',' '{sum += $3} END {print sum/NR}' | bc -l | xargs printf "%.2f")
  
  # 生成报告
  echo "==================== $YESTERDAY 系统性能报告 ====================" > "$REPORT_FILE"
  echo "CPU 平均使用率：$CPU_AVG%" >> "$REPORT_FILE"
  echo "内存平均使用率：$MEM_AVG%" >> "$REPORT_FILE"
  echo "磁盘使用率范围：$(echo "$YESTERDAY_DATA" | awk -F ',' '{print $4}' | sort -n | head -1)% - $(echo "$YESTERDAY_DATA" | awk -F ',' '{print $4}' | sort -n | tail -1)%" >> "$REPORT_FILE"
  echo "==============================================================" >> "$REPORT_FILE"
  
  # 可选：发送日报邮件
  # cat "$REPORT_FILE" | mail -s "$YESTERDAY 系统性能日报" admin@example.com
  echo "已生成 $YESTERDAY 系统性能报告"
fi
```


#### 5.5.4 多服务器批量操作工具
通过 SSH 批量在多台服务器上执行命令（需配置免密登录）：
```bash
#!/bin/bash
# 多服务器批量操作脚本：在多台服务器上执行相同命令
# 服务器列表文件格式：每行一个 IP（需提前配置 SSH 免密登录）

# 检查参数
if [ $# -ne 2 ]; then
  echo "使用方法：$0 [服务器列表文件] [要执行的命令]"
  echo "示例：$0 servers.txt 'df -h'"
  exit 1
fi

SERVER_LIST=$1
COMMAND=$2

# 检查服务器列表文件
if [ ! -f "$SERVER_LIST" ]; then
  echo "错误：服务器列表文件 $SERVER_LIST 不存在！"
  exit 1
fi

# 遍历服务器列表执行命令
while IFS= read -r server; do
  # 跳过空行
  [ -z "$server" ] && continue
  
  echo "==================== 正在操作服务器：$server ===================="
  ssh "$server" "$COMMAND"
  echo "================================================================="
  echo
done < "$SERVER_LIST"
```


#### 5.5.5 进程守护脚本
监控指定进程，若意外退出则自动重启：
```bash
#!/bin/bash
# 进程守护脚本：监控进程并自动重启
# 使用方法：./daemon.sh [进程名] [启动命令]

# 参数检查
if [ $# -ne 2 ]; then
  echo "使用方法：$0 [进程名] [启动命令]"
  echo "示例：$0 'java -jar app.jar' 'java -jar /opt/app.jar'"
  exit 1
fi

PROCESS_NAME=$1
START_COMMAND=$2
LOG_FILE="/var/log/daemon_$(echo "$PROCESS_NAME" | tr ' ' '_').log"

# 日志函数
log() {
  echo "[$(date "+%Y-%m-%d %H:%M:%S")] $1" >> "$LOG_FILE"
}

# 监控循环
while true; do
  # 检查进程是否存在
  if ! pgrep -f "$PROCESS_NAME" > /dev/null; then
    log "进程 '$PROCESS_NAME' 未运行，正在重启..."
    # 启动进程（后台运行）
    $START_COMMAND &
    # 记录进程 PID
    PID=$!
    log "进程已重启，PID: $PID"
  fi
  # 每 10 秒检查一次
  sleep 10
done
```


#### 5.5.6 交互式菜单脚本
创建带菜单的交互式脚本，方便用户选择操作：
```bash
#!/bin/bash
# 交互式系统管理菜单
clear
echo "==================== 系统管理工具 ===================="
echo "1. 查看系统信息"
echo "2. 磁盘空间检查"
echo "3. 内存使用情况"
echo "4. 进程列表"
echo "5. 网络连接"
echo "6. 退出"
echo "======================================================"

read -p "请输入选项 (1-6): " choice

case $choice in
  1)
    echo "===== 系统信息 ====="
    uname -a
    echo "主机名: $(hostname)"
    echo "系统版本: $(cat /etc/os-release | grep PRETTY_NAME | cut -d '"' -f 2)"
    echo "内核版本: $(uname -r)"
    ;;
  2)
    echo "===== 磁盘空间 ====="
    df -h
    ;;
  3)
    echo "===== 内存使用 ====="
    free -h
    ;;
  4)
    echo "===== 进程列表 ====="
    ps aux | head -10
    ;;
  5)
    echo "===== 网络连接 ====="
    netstat -tuln
    ;;
  6)
    echo "退出工具，再见！"
    exit 0
    ;;
  *)
    echo "无效选项，请重新运行脚本并输入 1-6 之间的数字"
    ;;
esac
```

## 六、常用脚本示例
### 6.1 文件备份脚本
```bash
#!/bin/bash
# 备份目标目录
SOURCE_DIR="/home/user/data"
# 备份存储目录
BACKUP_DIR="/home/user/backup"
# 备份文件名（包含日期）
BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).tar.gz"

# 检查源目录是否存在
if [ ! -d $SOURCE_DIR ]; then
  echo "错误：源目录 $SOURCE_DIR 不存在！"
  exit 1
fi

# 创建备份目录（不存在则创建）
mkdir -p $BACKUP_DIR

# 执行备份（tar 打包压缩）
tar -zcvf $BACKUP_DIR/$BACKUP_FILE $SOURCE_DIR

# 检查备份是否成功
if [ $? -eq 0 ]; then
  echo "备份成功！备份文件：$BACKUP_DIR/$BACKUP_FILE"
else
  echo "备份失败！"
  exit 1
fi

# 可选：删除 7 天前的备份文件（清理旧备份）
find $BACKUP_DIR -name "backup_*.tar.gz" -mtime +7 -delete
```

### 6.2 日志清理脚本
```bash
#!/bin/bash
# 日志目录
LOG_DIR="/var/log"
# 保留日志天数
RETENTION_DAYS=30

# 检查日志目录是否存在
if [ ! -d $LOG_DIR ]; then
  echo "错误：日志目录 $LOG_DIR 不存在！"
  exit 1
fi

# 清理指定天数前的日志文件（仅清理 .log 后缀）
find $LOG_DIR -name "*.log" -type f -mtime +$RETENTION_DAYS -delete

echo "日志清理完成！已删除 $RETENTION 天前的 .log 文件"
```

### 6.3 系统监控脚本
```bash
#!/bin/bash
# 系统监控脚本：输出 CPU、内存、磁盘使用率
DATE=$(date "+%Y-%m-%d %H:%M:%S")
echo "==================== 系统监控报告 ($DATE) ===================="

# CPU 使用率（取 top 命令的第 3 行，提取 %Cpu(s) 后的数值）
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')
echo "CPU 使用率：$CPU_USAGE%"

# 内存使用率（free 命令，计算已用/总内存）
MEM_TOTAL=$(free -m | grep Mem | awk '{print $2}')
MEM_USED=$(free -m | grep Mem | awk '{print $3}')
MEM_USAGE=$(echo "scale=2; $MEM_USED / $MEM_TOTAL * 100" | bc)
echo "内存使用率：$MEM_USAGE%（已用：$MEM_USED MB / 总：$MEM_TOTAL MB）"

# 磁盘使用率（df 命令，提取 / 分区的使用率）
DISK_USAGE=$(df -h | grep "/$" | awk '{print $5}')
echo "磁盘使用率（/ 分区）：$DISK_USAGE"
echo "=============================================================="
```

## 七、常见问题与注意事项
1. **语法错误**：
   - `=` 两边不能有空格（变量赋值）
   - `[ ]` 两边必须有空格（条件判断）
   - 字符串包含空格时需用双引号包裹
2. **权限问题**：
   - 脚本执行时提示 "Permission denied"：需赋予执行权限（`chmod +x script.sh`）
   - 操作系统文件时权限不足：用 `sudo` 运行脚本
3. **路径问题**：
   - 脚本中尽量使用绝对路径（避免切换目录后执行失败）
   - 新增命令路径到 PATH：`export PATH=$PATH:/新路径`（临时生效，永久生效需写入 `~/.bashrc` 或 `/etc/profile`）
4. **特殊字符处理**：
   - 字符串包含 `$`、`&`、`*` 等特殊字符时，需用单引号包裹或转义（`\$`、`\&`）
5. **换行符问题**：
   - Windows 下编辑的脚本在 Linux 中执行报错：因 Windows 换行符为 `\r\n`，Linux 为 `\n`，需转换（`dos2unix script.sh`）

## 八、学习资源推荐
1. **官方文档**：
   - [Bash 官方手册](https://www.gnu.org/software/bash/manual/)
2. **在线教程**：
   - [Shell 脚本教程 - 菜鸟教程](https://www.runoob.com/linux/linux-shell.html)
   - [Linux Shell 编程指南](https://linux.cn/article-10080-1.html)
3. **书籍**：
   - 《Linux Shell 编程实战》
   - 《Shell 编程艺术》
4. **工具**：
   - 在线 Shell 编辑器：[ShellCheck](https://www.shellcheck.net/)（语法检查）
   - 本地调试：`bash -x` 命令（跟踪脚本执行过程）

---

本教程涵盖 Shell 编程的核心知识点，可作为入门指南和日常查阅手册。建议结合实际场景多写脚本练习，逐步掌握 Shell 的强大功能。如果遇到具体问题，可通过 `man 命令名`（如 `man bash`、`man grep`）查看官方文档获取详细信息。