# MySQL 六大核心约束类型详解
MySQL的六大核心约束，分别从唯一性、非空性、关联性、默认值、自定义规则等维度限制数据，是保障数据完整性的关键机制。下面将逐一拆解每种约束的定义、使用场景、语法细节及注意事项，帮你彻底掌握。
## 一、主键约束（PRIMARY KEY）：表的“唯一身份证”
### 1. 核心定义
主键约束是表中**唯一标识每条记录**的约束，确保数据不重复、不缺失，是表的“主键”字段。

### 2. 关键特性
- **唯一性**：主键字段的所有值必须唯一，不能有重复（如学生表的“学号”不能重复）。
- **非空性**：主键字段的值不能为`NULL`，必须有具体值（每条记录都得有“身份证”）。
- **单一性**：一个表**只能有1个主键**，但主键可以由多个字段组成（即“联合主键”，如成绩表的“学号+课程号”）。

### 3. 语法示例
#### （1）创建表时添加主键
```sql
-- ① 单字段主键（常用）
CREATE TABLE student (
  id INT PRIMARY KEY, -- 学号作为主键
  name VARCHAR(50) NOT NULL
);

-- ② 联合主键（多字段组合唯一）
CREATE TABLE score (
  stu_id INT, -- 学号
  course_id INT, -- 课程号
  score INT,
  PRIMARY KEY (stu_id, course_id) -- 学号+课程号组合成主键，确保同一学生同一课程只有一条成绩
);
```

#### （2）表创建后添加主键
```sql
-- 给student表的id字段添加主键（需确保id字段无重复、无NULL值）
-- 作用：修改 id 列的定义，在调整列数据类型（这里仍为 INT）的同时，直接为其添加主键约束。
-- 适用场景：通常用于首次为 id 列设置主键，且可能需要同时修改列的其他属性（如数据类型、是否允许为 NULL 等）。
-- 注意：如果 id 列原本允许为 NULL，执行此语句会自动将其改为 NOT NULL（因为主键列必须非空）。
ALTER TABLE student 
MODIFY COLUMN id INT PRIMARY KEY;

-- 作用：直接为已存在的 id 列添加主键约束，不修改列的其他定义（如数据类型）。
-- 适用场景：id 列已定义为非空 INT 类型，仅需单独添加主键约束时使用。
-- 注意：执行前需确保 id 列已设置为 NOT NULL，且列中数据无重复（否则会报错）。
ALTER TABLE student ADD PRIMARY KEY (id);
```

#### （3）删除主键
```sql
-- 删除student表的主键（若主键是自增字段，需先取消自增）
    -- 先取消自增
    -- ALTER TABLE person MODIFY COLUMN id INT;
ALTER TABLE student DROP PRIMARY KEY;
```

### 4. 常见使用场景
- 所有业务表的核心标识字段（如用户表的`user_id`、订单表的`order_id`）。
- 需与其他表关联的字段（通常作为外键的关联目标）。

### 5. 注意事项
- 推荐用**无业务含义的INT自增字段**作为主键（如`id INT AUTO_INCREMENT PRIMARY KEY`），避免用“手机号”“身份证号”等业务字段（后续业务变更可能导致主键值修改）。
- 联合主键需谨慎使用：后续新增字段、关联查询时会更复杂，优先用单字段主键+唯一约束替代。


## 二、外键约束（FOREIGN KEY）：表间的“关联纽带”
### 1. 核心定义
外键约束用于**关联两张表**（父表和子表），确保子表的“关联字段”值，必须在父表的“主键/唯一键”中存在，避免出现“孤儿数据”（如成绩表的“学号”，必须在学生表中存在）。

### 2. 关键概念
- **父表**：被关联的表，通常是存储核心数据的表（如学生表`student`）。
- **子表**：添加外键的表，通常是依赖核心数据的表（如成绩表`score`）。
- **关联规则**：父表删除/更新记录时，子表的关联记录如何处理（如级联删除、设为NULL）。

### 3. 语法示例
#### （1）创建表时添加外键
```sql
-- 父表：学生表（需先创建）
CREATE TABLE student (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL
);

-- 子表：成绩表（添加外键关联学生表的id）
CREATE TABLE score (
  id INT PRIMARY KEY AUTO_INCREMENT,
  stu_id INT, -- 关联学生表的id
  course_id INT,
  score INT,
  -- 外键约束：stu_id关联student表的id，父表删除时子表同步删除
  FOREIGN KEY (stu_id) 
  REFERENCES student(id) 
  ON DELETE CASCADE -- 关联规则：父表记录删除，子表关联记录也删除
);
```

#### （2）表创建后添加外键
```sql
-- 给score表的stu_id字段添加外键（需确保stu_id值都在student.id中存在）
ALTER TABLE score 
ADD CONSTRAINT fk_score_student -- 自定义外键名（规范：fk_子表_父表）
FOREIGN KEY (stu_id) 
REFERENCES student(id) 
ON UPDATE CASCADE; -- 关联规则：父表id更新，子表stu_id同步更新
```

#### （3）删除外键
```sql
-- 1. 先查看外键名（通过SHOW CREATE TABLE确认）
SHOW CREATE TABLE score; -- 假设外键名是fk_score_student

-- 2. 删除外键
ALTER TABLE score 
DROP FOREIGN KEY fk_score_student;
```

### 4. 常用关联规则（ON DELETE / ON UPDATE）
| 规则          | 作用（以父表删除记录为例）                                  | 适用场景                  |
|---------------|-------------------------------------------------------------|---------------------------|
| `CASCADE`     | 父表删除/更新，子表关联记录同步删除/更新                    | 成绩表关联学生表（学生删，成绩也删） |
| `SET NULL`    | 父表删除/更新，子表关联字段设为`NULL`（需子表字段允许为NULL）| 订单表关联用户表（用户删，订单保留但用户ID设为NULL） |
| `RESTRICT`    | 父表有子表关联记录时，禁止删除/更新（默认规则）              | 客户表关联合同表（避免误删客户导致合同无归属） |
| `NO ACTION`   | 与`RESTRICT`效果一致（部分数据库语法差异，MySQL中等同于RESTRICT） | 同RESTRICT                |

### 5. 注意事项
- **字段类型必须一致**：子表外键字段与父表关联字段的类型、长度、符号必须完全相同（如父表`id`是`INT UNSIGNED`，子表`stu_id`也必须是`INT UNSIGNED`）。
- **高并发场景慎用**：外键会增加数据库校验开销，且会限制分库分表（子表和父表必须在同一数据库），大型项目建议用“业务逻辑”维护表间关联（如插入成绩前，先查学生是否存在）。


## 三、唯一约束（UNIQUE）：字段的“唯一通行证”
### 1. 核心定义
唯一约束确保表中**指定字段的所有值唯一**，不允许重复，但允许字段值为`NULL`（且`NULL`值只能出现一次）。

### 2. 与主键约束的区别
| 对比维度       | 唯一约束（UNIQUE）                | 主键约束（PRIMARY KEY）           |
|----------------|-----------------------------------|-----------------------------------|
| 允许`NULL`     | 允许（但仅1个`NULL`）             | 不允许                            |
| 数量限制       | 一个表可多个唯一约束              | 一个表仅1个主键                  |
| 索引默认创建   | 自动创建唯一索引                  | 自动创建主键索引                  |
| 作用           | 保证非核心字段的唯一性（如邮箱）  | 保证表的核心唯一标识（如ID）      |

### 3. 语法示例
#### （1）创建表时添加唯一约束
```sql
CREATE TABLE user (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(100) UNIQUE, -- 邮箱唯一（允许NULL，但只能有1个NULL）
  phone CHAR(11) UNIQUE -- 手机号唯一（不允许重复）
);
```

#### （2）表创建后添加唯一约束
```sql
-- 给user表的phone字段添加唯一约束（需确保phone无重复值）
ALTER TABLE user 
ADD UNIQUE INDEX uk_user_phone (phone); -- 自定义索引名（规范：uk_表名_字段名）
```

#### （3）删除唯一约束
```sql
-- 1. 先查看唯一约束对应的索引名（唯一约束本质是唯一索引）
SHOW INDEX FROM user; -- 假设索引名是uk_user_phone

-- 2. 删除唯一约束（即删除对应的唯一索引）
ALTER TABLE user 
DROP INDEX uk_user_phone;
```

### 4. 常见使用场景
- 业务中需唯一标识的非核心字段（如用户表的“邮箱”“手机号”、商品表的“商品编码”）。
- 需避免重复操作的字段（如订单表的“订单编号”，即使有主键，也可加唯一约束双重保障）。

### 5. 注意事项
- `NULL`值的特殊性：唯一约束允许字段值为`NULL`，但多个`NULL`会被判定为重复（MySQL中`NULL != NULL`，但唯一约束会将多个`NULL`视为重复）。
- 复合唯一约束：可对多个字段加唯一约束（如“用户ID+商品ID”，确保用户不会重复收藏同一商品），语法为`UNIQUE (user_id, goods_id)`。


## 四、非空约束（NOT NULL）：字段的“必填项”
### 1. 核心定义
非空约束确保表中**指定字段的值不能为`NULL`**，插入或更新数据时，必须给该字段赋值，否则报错。

### 2. 关键特性
- 强制字段“必填”，避免出现“空值”导致的业务逻辑异常（如用户表的“用户名”不能为空）。
- 可与默认值约束（DEFAULT）配合：若未手动赋值，自动用默认值填充（既满足非空，又减少手动输入）。

### 3. 语法示例
#### （1）创建表时添加非空约束
```sql
CREATE TABLE user (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL, -- 用户名必填
  age INT, -- 年龄可选（允许NULL）
  status TINYINT NOT NULL DEFAULT 1 -- 状态必填，默认值为1（正常）
);
```

#### （2）表创建后添加/取消非空约束
```sql
-- ① 添加非空约束：将age字段改为必填（需确保现有age无NULL值）
ALTER TABLE user 
MODIFY COLUMN age INT NOT NULL;

-- ② 取消非空约束：将age字段改为允许NULL
ALTER TABLE user 
MODIFY COLUMN age INT NULL;
```

### 4. 常见使用场景
- 业务核心必填字段（如用户表的“用户名”“密码”、订单表的“金额”“创建时间”）。
- 后续查询/统计中不可缺失的字段（如商品表的“分类ID”，若为空会导致分类统计错误）。

### 5. 注意事项
- 避免过度使用：非核心字段（如用户表的“简介”“头像URL”）无需加非空约束，允许为空更灵活。
- 与默认值配合：若字段非空但常需“默认值”（如“状态”“性别”），优先加`NOT NULL DEFAULT 初始值`，减少业务代码的赋值操作。


## 五、默认值约束（DEFAULT）：字段的“默认填充值”
### 1. 核心定义
默认值约束用于**给字段设置“默认值”**，当插入数据时未手动指定该字段值，MySQL会自动用默认值填充。

### 2. 关键特性
- 仅在“未赋值”时生效：若插入数据时明确给字段赋值（即使值与默认值相同），会用手动赋值。
- 默认值需与字段类型匹配：如`INT`字段默认值不能是字符串，`DATE`字段默认值不能是数字。

### 3. 语法示例
#### （1）创建表时添加默认值约束
```sql
CREATE TABLE order (
  id INT PRIMARY KEY AUTO_INCREMENT,
  amount DECIMAL(10,2) NOT NULL, -- 金额必填
  pay_time DATETIME DEFAULT CURRENT_TIMESTAMP, -- 支付时间默认当前时间
  status TINYINT DEFAULT 0, -- 订单状态默认0（未支付）
  remark VARCHAR(200) DEFAULT '' -- 备注默认空字符串（避免NULL）
);
```

#### （2）表创建后添加/修改默认值
```sql
-- ① 添加默认值：给remark字段设默认值为空字符串
ALTER TABLE order 
MODIFY COLUMN remark VARCHAR(200) DEFAULT '';

-- ② 修改默认值：将status字段默认值从0改为1
ALTER TABLE order 
MODIFY COLUMN status TINYINT DEFAULT 1;

-- ③ 删除默认值：将status字段的默认值取消（改为NULL）
ALTER TABLE order 
MODIFY COLUMN status TINYINT DEFAULT NULL;
```

### 4. 常见使用场景
- 有固定初始值的字段（如“状态”默认“未激活”、“性别”默认“未知”）。
- 需自动填充时间的字段（如`create_time`默认`CURRENT_TIMESTAMP`，`update_time`默认`CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`）。
- 需避免`NULL`的可选字段（如“备注”默认空字符串，比`NULL`更便于后续处理）。

### 5. 注意事项
- 特殊默认值：`CURRENT_TIMESTAMP`可用于`DATETIME`/`TIMESTAMP`字段，自动填充当前时间；`ON UPDATE CURRENT_TIMESTAMP`可实现“更新时自动刷新时间”（如`update_time`字段）。
- 与非空约束配合：若字段默认值是“有效数据”（如`status DEFAULT 0`），建议同时加`NOT NULL`，避免默认值生效后仍出现`NULL`。


## 六、检查约束（CHECK）：字段的“自定义规则”
### 1. 核心定义
检查约束用于**自定义字段值的校验规则**，仅允许符合规则的数据存入表中（如成绩必须在0~100之间、年龄必须大于0）。

### 2. 关键特性
- MySQL 8.0.16+ 才完全支持：之前版本虽支持`CHECK`语法，但不会实际校验（需用触发器或业务逻辑替代）。
- 支持简单逻辑：规则可包含比较运算符（`>`, `<`, `=`, `BETWEEN`等）和逻辑运算符（`AND`, `OR`），复杂逻辑需用业务代码实现。

### 3. 语法示例
#### （1）创建表时添加检查约束
```sql
CREATE TABLE student (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  age INT CHECK (age > 0 AND age <= 150), -- 年龄必须在1~150之间
  score INT CHECK (score BETWEEN 0 AND 100), -- 成绩必须在0~100之间
  gender CHAR(1) CHECK (gender IN ('男', '女', '未知')) -- 性别只能是指定值
);
```

#### （2）表创建后添加检查约束
```sql
-- 给student表的age字段添加检查约束（年龄大于10）
ALTER TABLE student 
ADD CONSTRAINT chk_student_age -- 自定义约束名（规范：chk_表名_字段名）
CHECK (age > 10);
```

#### （3）删除检查约束
```sql
-- 1. 先查看检查约束名（通过SHOW CREATE TABLE确认）
SHOW CREATE TABLE student; -- 假设约束名是chk_student_age

-- 2. 删除检查约束
ALTER TABLE student 
DROP CONSTRAINT chk_student_age;
```

### 4. 常见使用场景
- 字段值有明确范围/枚举的场景（如成绩0~100、订单金额大于0、性别仅“男/女/未知”）。
- 需简单数据校验的场景（如身份证号长度18位、手机号长度11位）。

### 5. 注意事项
- 复杂逻辑不适用：检查约束仅支持简单表达式（如`score > 0`），不支持函数调用（如`LEN(phone) = 11`在部分MySQL版本不生效）或子查询，复杂校验需用业务代码。
- 兼容性问题：若项目需兼容MySQL 8.0.16以下版本，建议用“唯一约束+触发器”或“业务代码”替代检查约束，避免校验失效。
